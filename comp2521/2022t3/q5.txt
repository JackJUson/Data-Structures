Question 5

(a) How many times is the statement in line 3 executed (initialization
    of components) in terms of n and m? 
    
    n times

(b) How many times is the statement in line 6 executed (deleting an edge
    from the list of edges) in terms of n and m?

    m times

(c) What is the time complexity (in big-O notation) of testing whether
    two nodes are in different components?

    O(1)

(d) In the worst case, how many times is the statement in line 8
    executed (merging two components) in terms of n and m? Justify your
    answer.

    Worst case would be when vertices u and v are in different components
    for every edge {u,v} in Edges array. Since that would lead to the 
    maximum number of times merging the component would occur.
    Therefore for worst case line 8 would occur m number of times.

    min(n - 1, m).

    Initially, there are n components, because each node is in its own seperate
    component. Merging two components reduces the number of components by one,
    so this can be done at most n - 1 times (as merging will stop once there is
    only one component left).


(e) What is the worst case time complexity (in big-O notation) of
    merging two components into a single component? Justify your answer.

    -- O(1) because from the above algorithm, worst case for ONLY two components
    would always be given within one single edge, i.e. the vertices that
    make up the edge. Since merging components is constant time due to
    directly changing the value to one component, worst case merging two
    components into one component is O(1). -- wrong

    Merging two components i and j (where i < j) involves finding all nodes
    which are in component j and setting their component number to i. The 
    simplest and most efficient way to achieve this is to iterate through the 
    component[] array once, which is O(n).

(f) What is the overall worst case time complexity (in big-O notation)
    of this algorithm? Ignore the complexity of lines 1 and 4. Justify
    your answer.

    -- O(n + m) or O(n) if lower term of m is removed and since number of
    vertices is always greater than the number of edges. (This depends 
    on how far the lower term of Big O notation is reduced to)

    Since the initialization takes O(n) for every vertex and that is 
    the only iteration apart from the iteration for all the edges 
    (which is O(m)), the big O notation of this algorithm is O(n). --wrong

    O(n * min(n - 1, m))

    The time complexity of the for loop is O(n).

    The time complexity of the while loop is O(m + n * min(n - 1, m)), where
    - The m comes from the fact that the loop repeatedly deletes edges until empty.
    - The n * min(n - 1, m) comes from the fact that merging occurs at most 
      min(n - 1, m) times and the time complexity of merging is O(n).

    Hence O(m + n * min(n - 1, m)), which can be simplified to O(n * min(n - 1, m))
